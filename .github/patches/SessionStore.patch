diff --git a/browser/components/sessionstore/SessionStore.sys.mjs b/browser/components/sessionstore/SessionStore.sys.mjs
index e31ad7f335966..c1fba74dfd38f 100644
--- a/browser/components/sessionstore/SessionStore.sys.mjs
+++ b/browser/components/sessionstore/SessionStore.sys.mjs
@@ -1064,6 +1064,25 @@ var SessionStoreInternal = {
     );
 
     if (state) {
+      /*@nora:inject:start*/
+      if (!state.windows.length) {
+        console.warn("Floorp Injections: No windows found in state");
+        const lastSessionWindows = state._closedWindows;
+        let closedTime = lastSessionWindows[0].closedAt;
+        for (let i = 0; i < lastSessionWindows.length; i++) {
+          let closedWindowTime = lastSessionWindows[i].closedAt;
+          // If the last closed window is closed in +-2000, we will restore it
+          if (
+            closedWindowTime >= closedTime - 10000 &&
+            closedWindowTime <= closedTime + 10000
+          ) {
+            state.windows.push(lastSessionWindows[i]);
+            state._closedWindows.splice(i, 1);
+          }
+        }
+      }
+      /*@nora:inject:end*/
+
       try {
         // If we're doing a DEFERRED session, then we want to pull pinned tabs
         // out so they can be restored.
@@ -4533,6 +4552,20 @@ var SessionStoreInternal = {
       winData.sizemodeBeforeMinimized = winData.sizemode;
     }
 
+    /*@nora:inject:start*/
+    let workspacesWindowId = aWindow.workspacesWindowId;
+    if (workspacesWindowId) {
+      winData.workspacesWindowId = workspacesWindowId;
+    } else {
+      delete winData.workspacesWindowId;
+    }
+
+    let floorpShouldNotRestore = !!(
+      aWindow.floorpWebPanelWindow || aWindow.floorpSsbWindow
+    );
+    winData.floorpShouldNotRestore = floorpShouldNotRestore;
+    /*@nora:inject:end*/
+
     var hidden = WINDOW_HIDEABLE_FEATURES.filter(function (aItem) {
       return aWindow[aItem] && !aWindow[aItem].visible;
     });
@@ -5592,7 +5625,11 @@ var SessionStoreInternal = {
         "screenX" in aWinData ? +aWinData.screenX : NaN,
         "screenY" in aWinData ? +aWinData.screenY : NaN,
         aWinData.sizemode || "",
-        aWinData.sizemodeBeforeMinimized || ""
+        /*@nora:inject:start*/
+        aWinData.sizemodeBeforeMinimized || "",
+        aWinData.workspacesWindowId || "",
+        aWinData.floorpShouldNotRestore || false
+        /*@nora:inject:end*/
       );
       this.restoreSidebar(aWindow, aWinData.sidebar, aWinData.isPopup);
     }, 0);
@@ -5648,7 +5685,10 @@ var SessionStoreInternal = {
     aLeft,
     aTop,
     aSizeMode,
-    aSizeModeBeforeMinimized
+    aSizeModeBeforeMinimized,
+    /*@nora:inject:start*/
+    workspacesWindowId
+    /*@nora:inject:end*/
   ) {
     var win = aWindow;
     var _this = this;
@@ -5790,6 +5830,15 @@ var SessionStoreInternal = {
             break;
         }
       }
+
+      /*@nora:inject:start*/
+      if (workspacesWindowId) {
+        aWindow.workspacesWindowId = workspacesWindowId;
+      } else {
+        aWindow.workspacesWindowId = Services.uuid.generateUUID().toString();
+      }
+      /*@nora:inject:end*/
+
       // since resizing/moving a window brings it to the foreground,
       // we might want to re-focus the last focused window
       if (this.windowToFocus) {
